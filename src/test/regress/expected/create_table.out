--
-- CREATE_TABLE
--
-- CREATE TABLE SYNTAX
--
-- CLASS DEFINITIONS
--
CREATE TABLE src(a int) with(autovacuum_enabled = off);
insert into src values(1);
CREATE TABLE hobbies_r (
	name		text,
	person 		text
) with(autovacuum_enabled = off);
CREATE TABLE equipment_r (
	name 		text,
	hobby		text
) with(autovacuum_enabled = off);
CREATE TABLE onek (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
) with(autovacuum_enabled = off);
CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
) with(autovacuum_enabled = off);
CREATE TABLE tenk2 (
	unique1 	int4,
	unique2 	int4,
	two 	 	int4,
	four 		int4,
	ten			int4,
	twenty 		int4,
	hundred 	int4,
	thousand 	int4,
	twothousand int4,
	fivethous 	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
) with(autovacuum_enabled = off);
CREATE TABLE person (
	name 		text,
	age			int4,
	location 	point
);
CREATE TABLE emp (
	name            text,
	age		int4,
	location	point,
	salary 		int4,
	manager 	name
) with(autovacuum_enabled = off);
CREATE TABLE student (
	name 		text,
	age			int4,
	location 	point,
	gpa		float8
);
CREATE TABLE stud_emp (
	name 		text,
	age			int4,
	location 	point,
	salary		int4,
	manager		name,
	gpa 		float8,
	percent		int4
) with(autovacuum_enabled = off);
CREATE TABLE city (
	name		name,
	location 	box,
	budget 		city_budget
) with(autovacuum_enabled = off);
ERROR:  type "city_budget" does not exist
LINE 4:  budget   city_budget
                  ^
CREATE TABLE dept (
	dname		name,
	mgrname 	text
) with(autovacuum_enabled = off);
CREATE TABLE slow_emp4000 (
	home_base	 box
) with(autovacuum_enabled = off);
CREATE TABLE fast_emp4000 (
	home_base	 box
) with(autovacuum_enabled = off);
CREATE TABLE road (
	name		text,
	thepath 	path
);
CREATE TABLE ihighway(
	name		text,
	thepath 	path
) with(autovacuum_enabled = off);
CREATE TABLE shighway (
	surface		text,
	name		text,
	thepath 	path
) with(autovacuum_enabled = off);
CREATE TABLE real_city (
	pop			int4,
	cname		text,
	outline 	path
) with(autovacuum_enabled = off);
--
-- test the "star" operators a bit more thoroughly -- this time,
-- throw in lots of NULL fields...
--
-- a is the type root
-- b and c inherit from a (one-level single inheritance)
-- d inherits from b and c (two-level multiple inheritance)
-- e inherits from c (two-level single inheritance)
-- f inherits from e (three-level single inheritance)
--
CREATE TABLE a_star (
	class		char,
	a 			int4
) with(autovacuum_enabled = off);
CREATE TABLE b_star (
	b 			text,
	class		char,
	a 			int4
) with(autovacuum_enabled = off);
CREATE TABLE c_star (
	c 			name,
	class		char,
	a 			int4
) with(autovacuum_enabled = off);
CREATE TABLE d_star (
	d 			float8,
	b 			text,
	class		char,
	a 			int4,
	c 			name
) with(autovacuum_enabled = off);
CREATE TABLE e_star (
	e 			int2,
	c 			name,
	class		char,
	a 			int4
) with(autovacuum_enabled = off);
CREATE TABLE f_star (
	f 			polygon,
	e 			int2,
	c 			name,
	class		char,
	a 			int4
) with(autovacuum_enabled = off);
CREATE TABLE aggtest (
	a 			int2,
	b			float4
) with(autovacuum_enabled = off);
CREATE TABLE hash_i4_heap (
	seqno 		int4,
	random 		int4
) with(autovacuum_enabled = off);
CREATE TABLE hash_name_heap (
	seqno 		int4,
	random 		name
) with(autovacuum_enabled = off);
CREATE TABLE hash_txt_heap (
	seqno 		int4,
	random 		text
) with(autovacuum_enabled = off);
-- PGXC: Here replication is used to ensure correct index creation
-- when a non-shippable expression is used.
-- PGXCTODO: this should be removed once global constraints are supported
CREATE TABLE hash_f8_heap (
	seqno		int4,
	random 		float8
)  with(autovacuum_enabled = off);
-- don't include the hash_ovfl_heap stuff in the distribution
-- the data set is too large for what it's worth
--
-- CREATE TABLE hash_ovfl_heap (
--	x			int4,
--	y			int4
-- );
CREATE TABLE bt_i4_heap (
	seqno 		int4,
	random 		int4
) with(autovacuum_enabled = off);
CREATE TABLE bt_name_heap (
	seqno 		name,
	random 		int4
) with(autovacuum_enabled = off);
CREATE TABLE bt_txt_heap (
	seqno 		text,
	random 		int4
);
CREATE TABLE bt_f8_heap (
	seqno 		float8,
	random 		int4
) with(autovacuum_enabled = off);
CREATE TABLE array_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
) with(autovacuum_enabled = off);
CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
) with(autovacuum_enabled = off);
CREATE TABLE IF NOT EXISTS test_tsvector(
	t text,
	a tsvector
);
CREATE TABLE IF NOT EXISTS test_tsvector(
	t text
) with(autovacuum_enabled = off);
NOTICE:  relation "test_tsvector" already exists, skipping
CREATE UNLOGGED TABLE unlogged1 (a int primary key);			-- OK
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "unlogged1_pkey" for table "unlogged1"
INSERT INTO unlogged1 VALUES (42);
CREATE UNLOGGED TABLE public.unlogged2 (a int primary key);		-- also OK
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "unlogged2_pkey" for table "unlogged2"
CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);	-- not OK
ERROR:  only temporary relations may be created in temporary schemas
CREATE TABLE pg_temp.implicitly_temp (a int primary key);		-- OK
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "implicitly_temp_pkey" for table "implicitly_temp"
CREATE TEMP TABLE explicitly_temp (a int primary key);			-- also OK
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "explicitly_temp_pkey" for table "explicitly_temp"
CREATE TEMP TABLE pg_temp.doubly_temp (a int primary key);		-- also OK
ERROR:  temporary tables cannot specify a schema name
CREATE TEMP TABLE public.temp_to_perm (a int primary key);		-- not OK
ERROR:  temporary tables cannot specify a schema name
DROP TABLE unlogged1, public.unlogged2;
--
-- CREATE TABLE AS TEST CASE: Expect the column typemod info is not lost on DN
--
CREATE TABLE hw_create_as_test1(C_CHAR CHAR(102400));
CREATE TABLE hw_create_as_test2(C_CHAR) as SELECT C_CHAR FROM hw_create_as_test1;
CREATE TABLE hw_create_as_test3 (C_CHAR CHAR(102400));
ALTER TABLE hw_create_as_test3 INHERIT hw_create_as_test2;
DROP TABLE hw_create_as_test2;
ERROR:  cannot drop table hw_create_as_test2 because other objects depend on it
DETAIL:  table hw_create_as_test3 depends on table hw_create_as_test2
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP TABLE hw_create_as_test3;
DROP TABLE hw_create_as_test1;
CREATE TABLE hw_create_as_test1(C_INT int);
CREATE TABLE hw_create_as_test2(C_INT) as SELECT C_INT FROM hw_create_as_test1;
ERROR:  relation "hw_create_as_test2" already exists in schema "public"
DETAIL:  creating new table with existing name in the same schema
CREATE TABLE hw_create_as_test3 (C_INT int);
ALTER TABLE hw_create_as_test3 INHERIT hw_create_as_test2;
ERROR:  child table is missing column "c_char"
DROP TABLE hw_create_as_test3;
DROP TABLE hw_create_as_test2;
DROP TABLE hw_create_as_test1;
CREATE TABLE hw_create_as_test1(COL1 numeric(10,2));
CREATE TABLE hw_create_as_test2(COL1) as SELECT COL1 FROM hw_create_as_test1;
CREATE TABLE hw_create_as_test3 (COL1 numeric(10,2));
ALTER TABLE hw_create_as_test3 INHERIT hw_create_as_test2;
DROP TABLE hw_create_as_test3;
DROP TABLE hw_create_as_test2;
DROP TABLE hw_create_as_test1;
CREATE TABLE hw_create_as_test1(COL1 timestamp(1));
CREATE TABLE hw_create_as_test2(COL1) as SELECT COL1 FROM hw_create_as_test1;
CREATE TABLE hw_create_as_test3 (COL1 timestamp(1));
ALTER TABLE hw_create_as_test3 INHERIT hw_create_as_test2;
DROP TABLE hw_create_as_test3;
DROP TABLE hw_create_as_test2;
DROP TABLE hw_create_as_test1;
CREATE TABLE hw_create_as_test1(COL1 int[2][2]);
CREATE TABLE hw_create_as_test2(COL1) as SELECT COL1 FROM hw_create_as_test1;
CREATE TABLE hw_create_as_test3 (COL1 int[2][2]);
ALTER TABLE hw_create_as_test3 INHERIT hw_create_as_test2;
DROP TABLE hw_create_as_test3;
DROP TABLE hw_create_as_test2;
DROP TABLE hw_create_as_test1;
create table hw_create_as_test1(col1 int);
insert into hw_create_as_test1 values(1);
insert into hw_create_as_test1 values(2);
create table hw_create_as_test2 as select * from hw_create_as_test1 with no data;
select count(*) from hw_create_as_test2;
 count 
-------
     0
(1 row)

explain (analyze on, costs off) create table hw_create_as_test3 as select * from hw_create_as_test1 with no data;
                         QUERY PLAN                         
------------------------------------------------------------
 Insert on hw_create_as_test3 (Actual time: never executed)
   ->  Result (Actual time: never executed)
         One-Time Filter: false
--? Total runtime:.*
(4 rows)

drop table hw_create_as_test1;
drop table hw_create_as_test2;
drop table hw_create_as_test3;
CREATE TABLE hw_create_as_test1(COL1 int);
insert into hw_create_as_test1 values(1);
insert into hw_create_as_test1 values(2);
CREATE TABLE hw_create_as_test2 as SELECT '001' col1, COL1 col2 FROM hw_create_as_test1;
select * from hw_create_as_test2 order by 1, 2;
 col1 | col2 
------+------
 001  |    1
 001  |    2
(2 rows)

DROP TABLE hw_create_as_test2;
DROP TABLE hw_create_as_test1;
-- Zero column table is not supported any more.
CREATE TABLE zero_column_table_test1();
ERROR:  must have at least one column
CREATE TABLE zero_column_table_test2();
ERROR:  must have at least one column
CREATE TABLE zero_column_table_test3(a INT);
ALTER TABLE zero_column_table_test3 DROP COLUMN a;
ERROR:  must have at least one column
DROP TABLE zero_column_table_test3;
CREATE TABLE zero_column_table_test6() with (orientation = column);
ERROR:  must have at least one column
CREATE TABLE zero_column_table_test7() with (orientation = column);
ERROR:  must have at least one column
CREATE TABLE zero_column_table_test8(a INT) with (orientation = column);
ALTER TABLE zero_column_table_test8 DROP COLUMN a;
ERROR:  must have at least one column
DROP TABLE zero_column_table_test8;
--test create table of pg_node_tree type
create table pg_node_tree_tbl1(id int,name pg_node_tree);
ERROR:  type pg_node_tree is not yet supported.
create table pg_node_tree_tbl2 as select * from pg_type;
ERROR:  type pg_node_tree is not yet supported.
-- test unreserved keywords for table name
CREATE TABLE app(a int);
CREATE TABLE movement(a int);
CREATE TABLE pool(a int);
CREATE TABLE profile(a int);
CREATE TABLE resource(a int);
CREATE TABLE store(a int);
CREATE TABLE than(a int);
CREATE TABLE workload(a int);
CREATE TABLE ignore(ignore int);
CREATE TABLE charset(charset int);
DROP TABLE app;
DROP TABLE movement;
DROP TABLE pool;
DROP TABLE profile;
DROP TABLE resource;
DROP TABLE store;
DROP TABLE than;
DROP TABLE workload;
DROP TABLE ignore;
DROP TABLE charset;
-- test orientation
CREATE TABLE orientation_test_1 (c1 int) WITH (orientation = column);
CREATE TABLE orientation_test_2 (c1 int) WITH (orientation = 'column');
CREATE TABLE orientation_test_3 (c1 int) WITH (orientation = "column");
CREATE TABLE orientation_test_4 (c1 int) WITH (orientation = row);
CREATE TABLE orientation_test_5 (c1 int) WITH (orientation = 'row');
CREATE TABLE orientation_test_6 (c1 int) WITH (orientation = "row");
DROP TABLE orientation_test_1;
DROP TABLE orientation_test_2;
DROP TABLE orientation_test_3;
DROP TABLE orientation_test_4;
DROP TABLE orientation_test_5;
DROP TABLE orientation_test_6;
CREATE SCHEMA "TEST";
CREATE SCHEMA "SCHEMA_TEST";
CREATE TABLE "SCHEMA_TEST"."Table" (
    column1 bigint,
    column2 bigint
);
CREATE TABLE "TEST"."Test_Table"(
    clm1 "SCHEMA_TEST"."Table",
    clm2 bigint);
    
select * from "TEST"."Test_Table";
 clm1 | clm2 
------+------
(0 rows)

set current_schema=information_schema;
create table test_info(a int, b int);
ERROR:  permission denied to create "information_schema.test_info"
DETAIL:  System catalog modifications are currently disallowed.
\d+ sql_features
                        Table "information_schema.sql_features"
      Column      |      Type      | Modifiers | Storage  | Stats target | Description 
------------------+----------------+-----------+----------+--------------+-------------
 feature_id       | character_data |           | extended |              | 
 feature_name     | character_data |           | extended |              | 
 sub_feature_id   | character_data |           | extended |              | 
 sub_feature_name | character_data |           | extended |              | 
 is_supported     | yes_or_no      |           | extended |              | 
 is_verified_by   | character_data |           | extended |              | 
 comments         | character_data |           | extended |              | 
Has OIDs: no
Options: orientation=row, compression=no

explain (verbose on, costs off) select count(*) from sql_features;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(*)
   ->  Seq Scan on information_schema.sql_features
         Output: feature_id, feature_name, sub_feature_id, sub_feature_name, is_supported, is_verified_by, comments
(4 rows)

select count(*) from sql_features;
 count 
-------
   672
(1 row)

reset current_schema;
create table t_serial(a int, b serial);
NOTICE:  CREATE TABLE will create implicit sequence "t_serial_b_seq" for serial column "t_serial.b"
create temp table t_tmp(a int, b serial);
ERROR:  It's not supported to create serial column on temporary table
create temp table t_tmp(like t_serial);
NOTICE:  CREATE TABLE will create implicit sequence "t_tmp_b_seq" for serial column "t_tmp.b"
ERROR:  Temporary sequences are not supported
set enable_beta_features = on;
create temp table t_tmp(like t_serial);
NOTICE:  CREATE TABLE will create implicit sequence "t_tmp_b_seq" for serial column "t_tmp.b"
select nextval('t_tmp_b_seq');
 nextval 
---------
       1
(1 row)

reset enable_beta_features;
set default_statistics_target = -50;
analyze t_serial;
drop table t_serial;
drop table t_tmp;
drop table "TEST"."Test_Table";
drop table "SCHEMA_TEST"."Table";
drop schema "TEST";
drop schema "SCHEMA_TEST";
\c postgres
-- test primary key is only supported in B mode
-- error
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11, f12));
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: ..., f12 varchar(20), f13 bool, constraint con_t_pri primary ke...
                                                             ^
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using hash(f11, f12));
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: ..., f12 varchar(20), f13 bool, constraint con_t_pri primary ke...
                                                             ^
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using hash(f11, f12)) with (orientation = column);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 1: ..., f12 varchar(20), f13 bool, constraint con_t_pri primary ke...
                                                             ^
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint primary key(f11));
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 1: ... test_primary(f11 int, f12 varchar(20), f13 bool, constraint...
                                                             ^
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11 desc, f12 asc));
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: ...ool, constraint con_t_pri primary key using btree(f11 desc, ...
                                                             ^
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key ((abs(f11))));
ERROR:  expression is supported only in B-format database.
LINE 1: ...(f11 int, f12 varchar(20), f13 bool, primary key ((abs(f11))...
                                                             ^
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key ((f11 * 2 + 1)));
ERROR:  expression is supported only in B-format database.
LINE 1: ...(f11 int, f12 varchar(20), f13 bool, primary key ((f11 * 2 +...
                                                             ^
-- success
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- test foreign key is only supported in B mode
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key (f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
-- error
create table test_foreign(f21 int, f22 timestamp, constraint con_t_foreign foreign key f_t_foreign (f21) references test_primary(f11));
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: ...(f21 int, f22 timestamp, constraint con_t_foreign foreign ke...
                                                             ^
create table test_foreign(f21 int, f22 timestamp, constraint foreign key f_t_foreign (f21) references test_primary(f11));
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: ...e test_foreign(f21 int, f22 timestamp, constraint foreign ke...
                                                             ^
create table test_foreign(f21 int, f22 timestamp, foreign key f_t_foreign (f21) references test_primary(f11));
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 1: create table test_foreign(f21 int, f22 timestamp, foreign ke...
                                                          ^
-- success
create table test_foreign(f21 int, f22 timestamp, constraint con_t_foreign foreign key (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp, foreign key (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "test_foreign_f21_fkey" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
drop table test_primary;
-- test unique key is only supported in B mode
-- error
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using btree(f31, f32));
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: ...f31 int, f32 varchar(20), constraint con_t_unique unique usi...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using hash(f31, f32));
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: ...f31 int, f32 varchar(20), constraint con_t_unique unique usi...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using hash(f31, f32)) with (orientation = column);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 1: ...f31 int, f32 varchar(20), constraint con_t_unique unique usi...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique u_t_unique(f31, f32));
ERROR:  UNIQUE name is supported only in B-format database.
LINE 1: ...f31 int, f32 varchar(20), constraint con_t_unique unique u_t...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), unique u_t_unique(f31, f32));
ERROR:  UNIQUE name is supported only in B-format database.
LINE 1: ...reate table test_unique(f31 int, f32 varchar(20), unique u_t...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), constraint unique (f31, f32));
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 1: ...reate table test_unique(f31 int, f32 varchar(20), constraint...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), unique (f31 desc, f32 asc));
ERROR:  ASC/DESC is supported only in B-format database.
LINE 1: ...ble test_unique(f31 int, f32 varchar(20), unique (f31 desc, ...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), unique ((abs(f31)) desc, (lower(f32)) asc));
ERROR:  expression is supported only in B-format database.
LINE 1: ...ble test_unique(f31 int, f32 varchar(20), unique ((abs(f31))...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), unique ((f31 * 2 + 1) desc, (lower(f32)) asc));
ERROR:  expression is supported only in B-format database.
LINE 1: ...ble test_unique(f31 int, f32 varchar(20), unique ((f31 * 2 +...
                                                             ^
-- success
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique (f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), unique (f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_f31_f32_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_f32_key" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- partition table
-- test primary key is only supported in B mode
-- error
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using btree(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 6:     constraint con_t_pri primary key using btree(f1, f2, f3)
                                 ^
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using hash(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 6:     constraint con_t_pri primary key using hash(f1, f2, f3)
                                 ^
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using hash(f1, f2, f3)
)
with (orientation = column)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  PRIMARY KEY USING access_method is supported only in B-format database.
LINE 6:     constraint con_t_pri primary key using hash(f1, f2, f3)
                                 ^
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint primary key(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 6:     constraint primary key(f1, f2, f3)
            ^
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key(f1 desc, f2 asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 6:     constraint con_t_pri primary key(f1 desc, f2 asc, f3)
                                             ^
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key((abs(f1)) desc, (f2 * 2 + 1) asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  expression is supported only in B-format database.
LINE 6:     constraint con_t_pri primary key((abs(f1)) desc, (f2 * 2...
                                             ^
-- success
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    primary key(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "test_p_primary_pkey" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
-- test foreign key is only supported in B mode
-- error
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_foreign foreign key f_t_foreign(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 6:     constraint con_t_foreign foreign key f_t_foreign(f1) ref...
                                     ^
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint foreign key f_t_foreign(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 6:     constraint foreign key f_t_foreign(f1) references test_p...
                       ^
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    foreign key f_t_foreign(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  FOREIGN KEY name is supported only in B-format database.
LINE 6:     foreign key f_t_foreign(f1) references test_p_primary(f1...
            ^
-- success
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_foreign foreign key(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    foreign key(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "test_p_foreign_f1_fkey" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
drop table test_p_primary;
-- test unique key is only supported in B mode
-- error
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique using btree(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 6:     constraint con_t_unique unique using btree(f1, f2, f3)
                                    ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique using hash(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 6:     constraint con_t_unique unique using hash(f1, f2, f3)
                                    ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique using hash(f1, f2, f3)
)
with (orientation = column)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  UNIQUE access_method_clause is supported only in B-format database.
LINE 6:     constraint con_t_unique unique using hash(f1, f2, f3)
                                    ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique u_t_unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  UNIQUE name is supported only in B-format database.
LINE 6:     constraint con_t_unique unique u_t_unique(f1, f2, f3)
                                    ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique u_t_unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  UNIQUE name is supported only in B-format database.
LINE 6:     unique u_t_unique(f1, f2, f3)
            ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  CONSTRAINT without constraint_name is supported only in B-format database.
LINE 6:     constraint unique(f1, f2, f3)
            ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique(f1 desc, f2 asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  ASC/DESC is supported only in B-format database.
LINE 6:     unique(f1 desc, f2 asc, f3)
                   ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique((abs(f1)) desc, (f2 * 2 + 1) asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  expression is supported only in B-format database.
LINE 6:     unique((abs(f1)) desc, (f2 * 2 + 1) asc, f3)
                   ^
-- success
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_p_unique_f1_f2_f3_key" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_p_unique_f1_f2_f3_key" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- b compatibility case
drop database if exists b;
NOTICE:  database "b" does not exist, skipping
create database b dbcompatibility 'b';
\c b
-- test primary key in M mode
-- test [index_type]
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11, f12));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using hash(f11, f12));
ERROR:  access method "hash" does not support unique indexes
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using hash(f11, f12)) with (orientation = column);
ERROR:  access method "hash" does not support column store
-- test [CONSTRAINT [constraint_name]]
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint primary key(f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) |           | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "test_primary_pkey" PRIMARY KEY, btree (f11) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- test [ASC|DESC]
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11 desc, f12 asc));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
-- test expression, error
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key ((abs(f11))));
ERROR:  primary keys cannot be expressions
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key ((f11 * 2 + 1)));
ERROR:  primary keys cannot be expressions
-- test foreign key in M mode
-- test [CONSTRAINT [constraint_name]] and [index_name]
create table test_primary(f11 int, f12 varchar(20), f13 bool, primary key (f11));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_pkey" for table "test_primary"
create table test_foreign(f21 int, f22 timestamp, constraint con_t_foreign foreign key f_t_foreign (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp, constraint con_t_foreign foreign key (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp, constraint foreign key f_t_foreign (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp, foreign key f_t_foreign (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
create table test_foreign(f21 int, f22 timestamp, foreign key (f21) references test_primary(f11));
\d+ test_foreign
                               Table "public.test_foreign"
 Column |            Type             | Modifiers | Storage | Stats target | Description 
--------+-----------------------------+-----------+---------+--------------+-------------
 f21    | integer                     |           | plain   |              | 
 f22    | timestamp without time zone |           | plain   |              | 
Foreign-key constraints:
    "test_foreign_f21_fkey" FOREIGN KEY (f21) REFERENCES test_primary(f11)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_foreign;
drop table test_primary;
-- test unique key in M mode
-- test [index_type]
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using btree(f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using hash(f31, f32));
ERROR:  access method "hash" does not support unique indexes
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using hash(f31, f32)) with (orientation = column);
ERROR:  access method "hash" does not support column store
-- test [CONSTRAINT [constraint_name]] and [index_name]
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique u_t_unique(f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), unique u_t_unique(f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique (f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint unique (f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_f31_f32_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_f32_key" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), unique (f31, f32));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_f31_f32_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_f32_key" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- test [ASC|DESC]
create table test_unique(f31 int, f32 varchar(20), unique (f31 desc, f32 asc));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_f31_f32_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_f31_f32_key" UNIQUE CONSTRAINT, btree (f31 DESC, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- test expression
create table test_unique(f31 int, f32 varchar(20), unique ((abs(f31)) desc, (lower(f32)) asc));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_abs_lower_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_abs_lower_key" UNIQUE CONSTRAINT, btree (abs(f31) DESC, lower(f32::text)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), unique ((f31 * 2 + 1) desc, (lower(f32)) asc));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_expr_lower_key" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "test_unique_expr_lower_key" UNIQUE CONSTRAINT, btree ((f31 * 2 + 1) DESC, lower(f32::text)) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
-- test unreserved_keyword index and key
-- error
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique key using btree(f31));
ERROR:  index/key cannot be used as unique name.
LINE 1: ...f31 int, f32 varchar(20), constraint con_t_unique unique key...
                                                             ^
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique index using btree(f31));
ERROR:  index/key cannot be used as unique name.
LINE 1: ...f31 int, f32 varchar(20), constraint con_t_unique unique ind...
                                                             ^
-- partition table
-- test primary key in M mode
-- test [index_type]
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using btree(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using hash(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  access method "hash" does not support unique indexes
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using hash(f1, f2, f3)
)
with (orientation = column)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  access method "hash" does not support column store
-- test [CONSTRAINT [constraint_name]]
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    primary key(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "test_p_primary_pkey" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint primary key(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_p_primary_pkey" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "test_p_primary_pkey" PRIMARY KEY, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
-- test [ASC|DESC]
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using btree(f1 desc, f2 asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
\d+ test_p_primary
                    Table "public.test_p_primary"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer | not null  | plain   |              | 
 f2     | integer | not null  | plain   |              | 
 f3     | integer | not null  | plain   |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_primary;
-- test expression, error
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key using btree((abs(f1)) desc, (f2 * 2 + 1) asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  partition table does not support expression index
-- test foreign key in M mode
-- test [CONSTRAINT [constraint_name]] and [index_name]
CREATE TABLE test_p_primary
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_pri primary key(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_p_primary"
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_foreign foreign key f_t_foreign(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_foreign foreign key(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "con_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint foreign key f_t_foreign(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    foreign key f_t_foreign(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "f_t_foreign" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
CREATE TABLE test_p_foreign
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    foreign key(f1) references test_p_primary(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
\d+ test_p_foreign
                    Table "public.test_p_foreign"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Foreign-key constraints:
    "test_p_foreign_f1_fkey" FOREIGN KEY (f1) REFERENCES test_p_primary(f1)
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_foreign;
drop table test_p_primary;
-- test unique key in M mode
-- test [index_type]
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique using btree(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- error
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique using hash(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  access method "hash" does not support unique indexes
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique using hash(f1, f2, f3)
)
with (orientation = column)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  access method "hash" does not support column store
-- test [CONSTRAINT [constraint_name]] and [index_name]
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique u_t_unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique u_t_unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "u_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "u_t_unique" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_p_unique_f1_f2_f3_key" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_p_unique_f1_f2_f3_key" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique(f1, f2, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_p_unique_f1_f2_f3_key" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_p_unique_f1_f2_f3_key" UNIQUE CONSTRAINT, btree (f1, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- test [ASC|DESC]
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique(f1 desc, f2 asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_p_unique_f1_f2_f3_key" for table "test_p_unique"
\d+ test_p_unique
                    Table "public.test_p_unique"
 Column |  Type   | Modifiers | Storage | Stats target | Description 
--------+---------+-----------+---------+--------------+-------------
 f1     | integer |           | plain   |              | 
 f2     | integer |           | plain   |              | 
 f3     | integer |           | plain   |              | 
Indexes:
    "test_p_unique_f1_f2_f3_key" UNIQUE CONSTRAINT, btree (f1 DESC, f2, f3) LOCAL TABLESPACE pg_default
Partition By RANGE(f1)
Number of partitions: 4 (View pg_partition to check each partition range.)
Has OIDs: no
Options: orientation=row, compression=no

drop table test_p_unique;
-- test expression
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    unique((abs(f1)) desc, (f2 * 2 + 1) asc, f3)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  partition table does not support expression index
\d+ test_p_unique
drop table test_p_unique;
ERROR:  table "test_p_unique" does not exist
-- test unreserved_keyword index and key
-- error
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique key using btree(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  index/key cannot be used as unique name.
LINE 6:     constraint con_t_unique unique key using btree(f1)
                                    ^
CREATE TABLE test_p_unique
(
    f1  INTEGER,
    f2  INTEGER,
    f3  INTEGER,
    constraint con_t_unique unique index using btree(f1)
)
PARTITION BY RANGE(f1)
(
        PARTITION P1 VALUES LESS THAN(2450815),
        PARTITION P2 VALUES LESS THAN(2451179),
        PARTITION P3 VALUES LESS THAN(2451544),
        PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
ERROR:  index/key cannot be used as unique name.
LINE 6:     constraint con_t_unique unique index using btree(f1)
                                    ^
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique using btree(f31, f32) comment 'unique index' using btree);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique (f31, f32) comment 'unique index' using btree);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_unique(f31 int, f32 varchar(20), constraint con_t_unique unique (f31, f32) comment 'unique index' using btree using btree);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "con_t_unique" for table "test_unique"
\d+ test_unique
                             Table "public.test_unique"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f31    | integer               |           | plain    |              | 
 f32    | character varying(20) |           | extended |              | 
Indexes:
    "con_t_unique" UNIQUE CONSTRAINT, btree (f31, f32) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_unique;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key (f11 desc, f12 asc) comment 'primary key' using btree);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
create table test_primary(f11 int, f12 varchar(20), f13 bool, constraint con_t_pri primary key using btree(f11 desc, f12 asc) comment 'primary key' using btree using btree);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "con_t_pri" for table "test_primary"
\d+ test_primary
                            Table "public.test_primary"
 Column |         Type          | Modifiers | Storage  | Stats target | Description 
--------+-----------------------+-----------+----------+--------------+-------------
 f11    | integer               | not null  | plain    |              | 
 f12    | character varying(20) | not null  | extended |              | 
 f13    | boolean               |           | plain    |              | 
Indexes:
    "con_t_pri" PRIMARY KEY, btree (f11 DESC, f12) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

drop table test_primary;
\c postgres
-- test mysql "create table as"
-- a format
create database a_createas dbcompatibility 'A';
\c a_createas
create table t_base(col1 int, col2 int, col3 int);
create table t1 as select * from t_base;
select * from t1;
 col1 | col2 | col3 
------+------+------
(0 rows)

create table t2(col) as select * from t_base;
select * from t2;
 col | col2 | col3 
-----+------+------
(0 rows)

-- fail
create table t3(col1,col2,col3,col4) as select * from t_base;
ERROR:  CREATE TABLE AS specifies too many column names
create table t4(col int) as select * from t_base;
ERROR:  define column_definition is supported only in B-format database
-- b format
create database b_createas dbcompatibility 'B';
\c b_createas
create table t_base(col1 int, col2 int, col3 int);
create table t1 as select * from t_base;
select * from t1;
 col1 | col2 | col3 
------+------+------
(0 rows)

create table t2(col) as select * from t_base;
select * from t2;
 col | col2 | col3 
-----+------+------
(0 rows)

create table t3(col int) as select * from t_base;
select * from t3;
 col | col1 | col2 | col3 
-----+------+------+------
(0 rows)

create table t4(col1 int) as select * from t_base;
select * from t4;
 col1 | col2 | col3 
------+------+------
(0 rows)

-- fail
create table t5() as select * from t_base;
ERROR:  syntax error at or near ")"
LINE 1: create table t5() as select * from t_base;
                        ^
create table t6(col1 int) as select col1,* from t_base;
ERROR:  column "col1" specified more than once
LINE 1: create table t6(col1 int) as select col1,* from t_base;
                                           ^
-- duplicate key
insert into t_base values(1,1,10),(1,2,9),(2,2,8),(2,1,7),(1,1,6);
-- error
create table t7(col1 int unique) as select * from t_base;
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t7_col1_key" for table "t7"
ERROR:  duplicate key value violates unique constraint "t7_col1_key"
DETAIL:  Key (col1)=(1) already exists.
-- ignore
create table t8(col1 int unique) ignore as select * from t_base;
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t8_col1_key" for table "t8"
select * from t8;
 col1 | col2 | col3 
------+------+------
    1 |    1 |   10
    2 |    2 |    8
(2 rows)

-- replace
create table t9(col1 int unique) replace as select * from t_base;
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t9_col1_key" for table "t9"
select * from t9 order by col3;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    6
    2 |    1 |    7
(2 rows)

create table t10(col1 int unique, col2 int unique) replace as select * from t_base;
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t10_col1_key" for table "t10"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t10_col2_key" for table "t10"
select * from t10 order by col3;
 col1 | col2 | col3 
------+------+------
    1 |    1 |    6
(1 row)

-- foreign key
create table ftable(col int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "ftable_pkey" for table "ftable"
create table t11(col int, foreign key(col) references ftable(col)) as select * from t_base;
ERROR:  CREATE TABLE AS SELECT is not allowed with Foreign Key
create table t12(col int references ftable(col)) as select * from t_base;
ERROR:  CREATE TABLE AS SELECT is not allowed with Foreign Key
create table t13(foreign key(col1) references ftable(col)) as select * from t_base;
ERROR:  CREATE TABLE AS SELECT is not allowed with Foreign Key
-- table like
create table t14(like t_base) as select * from t_base;
ERROR:  CREATE TABLE AS SELECT is not allowed with Tablelike Clause
-- with no data
create table t15(id int, name char(8));
insert into t15(id) select generate_series(1,10);
create table t16(col1 int, id int) as select * from t15 where id with no data;
select * from t16;
 col1 | id | name 
------+----+------
(0 rows)

create table t17(col1 int, id int unique) replace as select * from t15 where id with no data;
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "t17_id_key" for table "t17"
select * from t17;
 col1 | id | name 
------+----+------
(0 rows)

-- union all
create table test1(id int,name varchar(10),score numeric,date1 date,c1 bytea);
insert into test1 values(1,'aaa',97.1,'1999-12-12','0101');
insert into test1 values(5,'bbb',36.9,'1998-01-12','0110');
insert into test1 values(30,'ooo',90.1,'2023-01-30','1001');
insert into test1 values(6,'hhh',60,'2022-12-22','1010');
insert into test1 values(7,'fff',71,'2001-11-23','1011');
insert into test1 values(-1,'yaya',77.7,'2008-09-10','1100');
insert into test1 values(7,'fff',71,'2001-11-23','1011');
insert into test1 values(null,null,null,null,null);
create table test2(id int,name varchar(10),score numeric,date1 date,c1 bytea);
insert into test2 values(1,'aaa',99.1,'1998-12-12','0101');
insert into test2 values(2,'hhh',36.9,'1996-01-12','0110');
insert into test2 values(3,'ddd',89.2,'2000-03-12','0111');
insert into test2 values(7,'uuu',60.9,'1997-01-01','1000');
insert into test2 values(11,'eee',71,'2011-11-20','1011');
insert into test2 values(-1,'yaya',76.7,'2008-09-10','1100');
insert into test2 values(7,'uuu',60.9,'1997-01-01','1000');
insert into test2 values(null,null,null,null,null);
create table tb1(col1 int,id int) as select * from test1 where id<4 union all select * from test2 where score>80 order by id,score;
select * from tb1 order by id;
 col1 | id | name | score |   date1    |     c1     
------+----+------+-------+------------+------------
      | -1 | yaya |  77.7 | 09-10-2008 | \x31313030
      |  1 | aaa  |  97.1 | 12-12-1999 | \x30313031
      |  1 | aaa  |  99.1 | 12-12-1998 | \x30313031
      |  3 | ddd  |  89.2 | 03-12-2000 | \x30313131
(4 rows)

create table tb2(col1 int,id int unique) replace as select * from test1 where id<4 union all select * from test2 where score>80 order by id,score;
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "tb2_id_key" for table "tb2"
select * from tb2 order by id;
 col1 | id | name | score |   date1    |     c1     
------+----+------+-------+------------+------------
      | -1 | yaya |  77.7 | 09-10-2008 | \x31313030
      |  1 | aaa  |  99.1 | 12-12-1998 | \x30313031
      |  3 | ddd  |  89.2 | 03-12-2000 | \x30313131
(3 rows)

-- test update
create table tb_primary(a int primary key, b int);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "tb_primary_pkey" for table "tb_primary"
create table tb_unique(a int unique, b int);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "tb_unique_a_key" for table "tb_unique"
insert into tb_primary values(1,2),(2,4),(3,6);
insert into tb_unique values(1,2),(2,4),(3,6);
-- error
insert into tb_primary values(1,1);
ERROR:  duplicate key value violates unique constraint "tb_primary_pkey"
DETAIL:  Key (a)=(1) already exists.
insert into tb_unique values(1,1);
ERROR:  duplicate key value violates unique constraint "tb_unique_a_key"
DETAIL:  Key (a)=(1) already exists.
-- UPDATE nothing
insert into tb_primary values(1,1) ON DUPLICATE KEY UPDATE NOTHING;
insert into tb_unique values(1,1) ON DUPLICATE KEY UPDATE NOTHING;
select * from tb_primary;
 a | b 
---+---
 1 | 2
 2 | 4
 3 | 6
(3 rows)

select * from tb_unique;
 a | b 
---+---
 1 | 2
 2 | 4
 3 | 6
(3 rows)

-- UPDATE
insert into tb_primary values(1,1) ON DUPLICATE KEY UPDATE a = 1, b = 1;
insert into tb_unique values(1,1) ON DUPLICATE KEY UPDATE a = 1, b = 1;
select * from tb_primary;
 a | b 
---+---
 2 | 4
 3 | 6
 1 | 1
(3 rows)

select * from tb_unique;
 a | b 
---+---
 2 | 4
 3 | 6
 1 | 1
(3 rows)

\c postgres
drop database a_createas;
drop database b_createas;
